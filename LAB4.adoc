= Лабораторная работа №4
:toc: macro
:toc-title: Оглавление

include::Titulnik_salavat.adoc[]

toc::[]

== Введение

=== Тема лекции
Лекция посвящена основам портируемости программного обеспечения для встраиваемых систем, типам данных в языке C++, преобразованиям типов, работе с указателями и ссылками, а также организации памяти и регистров микроконтроллера STM32F411.

=== Цель лабораторной работы
Целью данной лабораторной работы является практическое освоение принципов портируемости программного кода для микроконтроллеров, изучение типов данных в C++, освоение работы с указателями и ссылками, а также получение навыков работы с регистрами периферии микроконтроллера STM32F411.

В ходе работы необходимо:
1. Научиться создавать портируемый код с использованием фиксированных типов данных
2. Освоить явные преобразования типов для предотвращения неявных ошибок
3. Изучить механизмы работы с указателями и ссылками в контексте встраиваемых систем
4. На практике освоить доступ к регистрам периферии микроконтроллера
5. Реализовать программу для управления портами ввода-вывода

== Основные термины и определения

**Портируемость (Portability)** — свойство программного обеспечения, позволяющее легко переносить его на различные платформы или микроконтроллеры.

**Тип данных (Data Type)** — характеристика переменной, определяющая множество значений, которые она может принимать, и операции, которые над ней можно выполнять.

**Указатель (Pointer)** — переменная, хранящая адрес другой переменной или области памяти.

**Ссылка (Reference)** — псевдоним переменной, позволяющий обращаться к ней под другим именем.

**Регистр (Register)** — ячейка памяти внутри процессора или периферийного модуля, используемая для хранения данных или управления устройством.

== Типы данных в C++

=== Встроенные типы данных
В C++ определены базовые типы данных, такие как:

- `bool` — логический тип (1 байт)
- `char` — символьный тип (1 байт)
- `int` — целочисленный тип (4 байта)
- `float` — число с плавающей точкой (4 байта)
- `double` — число с плавающей точкой двойной точности (8 байт)

=== Модификаторы типов
Для изменения размера и поведения типов используются модификаторы:

- `short` — укороченный тип (2 байта)
- `long` — удлинённый тип (8 байт)
- `unsigned` — беззнаковый тип

=== Правила размеров типов
Размеры типов могут различаться в зависимости от архитектуры. Для обеспечения портируемости рекомендуется использовать типы с фиксированным размером из библиотеки `<cstdint>`:

- `std::uint8_t` — беззнаковое 8-битное целое  
- `std::int32_t` — знаковое 32-битное целое

=== Пользовательские типы
Программист может определять собственные типы с помощью:

- **Структур (`struct`)**  
- **Классов (`class`)**  
- **Псевдонимов типов (`using` или `typedef`)**  

Пример структуры для комплексных чисел:

[source,cpp]
----
struct Complex {
    float real;
    float imag;
};
----

Пример класса:

[source,cpp]
----
class Sensor {
private:
    int id;
public:
    int readValue();
};
----

Пример псевдонима типа:

[source,cpp]
----
using PinNumber = uint8_t;
----

== Преобразования типов

=== Неявное преобразование
Компилятор автоматически преобразует типы в выражениях, что может приводить к потере данных:

[source,cpp]
----
int a = 3.14; // a = 3 (потеря дробной части)
char ch = 512; // ch = 0 (переполнение)
bool b = -4;   // b = true (любое ненулевое значение → true)
bool c = 0;    // c = false
----

=== Явное преобразование
Для контроля над преобразованиями используются операторы приведения:

- `static_cast` — для безопасных преобразований близких типов  
- `reinterpret_cast` — для преобразований между несвязанными типами  
- `const_cast` — для снятия или добавления константности  
- `dynamic_cast` — для преобразований в иерархии классов  

Пример:

[source,cpp]
----
int a = static_cast<int>(3.14); // a = 3
auto ptr = reinterpret_cast<volatile uint32_t*>(0x40010000);
----

== Указатели и ссылки

=== Указатели
Указатель — переменная, хранящая адрес другой переменной.

[source,cpp]
----
int c = 463;
int* ptr = &c; // ptr хранит адрес переменной c
----

==== Операции с указателями

- Взятие адреса: `&`  
- Разыменование: `*`  
- Арифметика указателей: `+`, `-`, `++`, `--`  

Пример работы с массивом:

[source,cpp]
----
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr++; // теперь указывает на arr[1]
----

=== Константные указатели

- Указатель на константу: `const int* ptr` — нельзя изменить значение  
- Константный указатель: `int* const ptr` — нельзя изменить адрес  

=== Ссылки
Ссылка — псевдоним переменной.

[source,cpp]
----
int a = 0;
int& ref = a; // ref — ссылка на a
ref = 10;     // теперь a = 10
----

==== Отличия ссылок от указателей:

- Ссылка должна быть инициализирована при объявлении  
- Нельзя изменить ссылку после инициализации  
- Нельзя выполнять арифметические операции над ссылками  
- Нельзя получить адрес ссылки (адрес ссылки = адрес переменной)  

== Регистры

**Регистр (Register)** — это быстрая ячейка памяти внутри процессора или периферийного модуля, используемая для хранения данных, адресов или управления устройством. Регистры могут быть общего или специального назначения.

=== Регистры общего назначения (РОН)
Микроконтроллер Cortex-M4 имеет 16 регистров общего назначения (R0–R15):

- `R0–R3`, `R12` — оперативные регистры (scratch)  
- `R4–R11` — вспомогательные регистры (callee-saved)  
- `R13 (SP)` — указатель стека  
- `R14 (LR)` — регистр связи (адрес возврата)  
- `R15 (PC)` — счётчик команд  

=== Регистры специального назначения
Используются для управления периферией. Каждый регистр имеет:

- Адрес в памяти  
- Размер (обычно 32 бита)  
- Поля (набор битов, отвечающих за конкретную функцию)  

Пример регистра управления таймером:

[plantuml]
----
rectangle "TIM1_CR1 Register (0x40010000)" as reg {
  rectangle "Bit 31-16: Reserved" as bits31_16
  rectangle "Bit 15-8:  Other control bits" as bits15_8
  rectangle "Bit 7-1:   Reserved" as bits7_1
  rectangle "Bit 0:     CEN (Counter Enable)" as bit0
}
bit0 : "0 = Disabled\n1 = Enabled"
----

== Операции с указателями

=== Арифметика указателей
Указатели можно складывать, вычитать и сравнивать.

[source,cpp]
----
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr += 2; // указывает на arr[2]
----

При арифметике указателей смещение происходит на размер типа:

`ptr + 1` смещается на `sizeof(*ptr)` байт.

[plantuml]
----
rectangle "Память" as memory {
  rectangle "0x1C: 5 (arr[4])" as arr4
  rectangle "0x18: 4 (arr[3])" as arr3
  rectangle "0x14: 3 (arr[2])" as arr2
  rectangle "0x10: 2 (arr[1])" as arr1
  rectangle "0x0C: 1 (arr[0])" as arr0
}

rectangle "Указатель ptr" as pointer {
  rectangle "До: 0x0C" as ptr_before
  rectangle "После: 0x10" as ptr_after
}

ptr_before --> arr0 : указывает
ptr_after --> arr1 : указывает после ptr++
----

=== Сравнение указателей
Указатели можно сравнивать с `nullptr` или друг с другом:

[source,cpp]
----
if (ptr != nullptr) {
    // действия с указателем
}
----


== Код программы для переключения состояния светодиода:

include::Код.adoc[]

== Вывод

В ходе лабораторной работы я научился создавать портируемый код для микроконтроллеров. Я понял, как важно использовать типы данных с фиксированным размером и явные преобразования типов, чтобы программа могла работать на разных платформах без ошибок.

На практике я освоил работу с указателями и ссылками: научился получать адреса переменных, разыменовывать указатели и работать с памятью напрямую. Особенно полезным оказался опыт работы с регистрами микроконтроллера — я смог настроить порты ввода-вывода и управлять светодиодами через прямое обращение к регистрам.